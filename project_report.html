<!DOCTYPE html>
<html>
<head>
<title>Rapport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h1>PROJET PYTHON</h1>
<h1>Les algorithmes de tris</h1>
<h2>Introduction</h2>
<p>Dans le cadre de ce projet, nous avons réalisé une application visant à montrer le fonctionnement des différents algorithmes de tris notamment en les vulgarisant grâce à une animation visuelle et auditive. Nous avons donc implémenté les tris suivants :</p>
<ul>
<li>le tri Insertion</li>
<li>le tri Selection</li>
<li>le tri Rapide</li>
<li>le tri Fusion</li>
<li>le tri par Base ( que nous appelerons plus communément Radix )</li>
</ul>
<p>Cet ensemble nous permet de couvrir une large variété de tris notamment les récursifs mais aussi de vous en faire découvrir un plus original, le tri Radix, qui ne fait aucune comparaison. Ce type de tri reste cependant peu utilisé car il n'est intéressant que dans certains cas très spécifiques. Dans ce rapport, nous parlerons très peu de la complexité des tris dans le cas général car dans un but de vulgarisation, un compteur de comparaisons sera implémenté et permettra à l'utilisateur de comparer l'éfficacité des tris entre eux.</p>
<h1>Sommaire</h1>
<h2>I) Présentation des différents algorithmes de tris</h2>
<h3>1.1) Le tri insertion</h3>
<h3>1.2) Le tri sélection</h3>
<h3>1.3) Le tri rapide</h3>
<h3>1.4) Le tri fusion</h3>
<h3>1.5) Le tri Radix</h3>
<h2>II) Présentation de notre conception du projet</h2>
<h3>2.1) Implémentation des tris graphiquement</h3>
<h3>2.2) Le problème du tri fusion et du tri par dénombrement</h3>
<h2>III) Présentation des options proposées</h2>
<h3>3.1) Le contrôle du temps</h3>
<h3>3.2) Les restrictions imposées à l'utilisateur</h3>
<h3>3.3) Le tri sonore</h3>
<h2>Conclusion</h2>
<h2>Partie 1: Présentation des différents algorithmes de tris</h2>
<h3>1.1) Le tri insertion</h3>
<p>Le tri insertion repose sur un principe de &quot;pas à pas&quot;. En effet, pour une liste donnée, celui-ci va considérer le premier élément comme une liste triée de longueur 1. Il va ensuite s'intéresser à l'élément suivant et le comparer avec les éléments de la liste déjà triée puis le placer là où il doit être. Il va ensuite continuer cette opération jusqu'à la fin de la liste. De par son fonctionnement, la partie gauche de la liste est toujours triée. Voici notre code :</p>
<pre><code>def insert_sort(self):

    for i in range(1, len(self.List_height)):
        current = self.List_height[i]
        j = i
        while j &gt; 0 and self.List_height[j - 1] &gt; current:
            self.List_height[j - 1], self.List_height[j] = self.List_height[j], self.List_height[j - 1] 
            j = j-1 
</code></pre>

<p>Une particularité de ce tri est que son efficacité est considérablement améliorée si la liste à triér possède déjà un certain ordre sur plusieurs éléments. C'est cette caractéristique particulière qui le désigne pour finir un tri plus complexe qui a déjà su ordonner une liste.</p>
<h3>1.2) Le tri sélection</h3>
<p>Le tri sélection peut être considéré comme un tri brut qui trie la liste donnée sans se soucier de la pertinence de sa démarche. Il commence au premier indice qu'il considère comme le minimum puis parcourt tout le restant de la liste à la recherche d'un élément encore plus petit. Il ne s'arrête qu'une fois la liste entièrement parcourue et est donc en possession de l'élément le plus petit de la liste qu'il échange avec le premier élément. Il va ensuite considérer le minimum comme étant le second élément de la liste et la parcourir entièrement pour en trouver un encore plus petit et ainsi de suite jusqu'à ce que la liste entière soit triée. On comprend bien que cet algorithme n'est pas optimal dans sa recherche du minimum car il recherche continuellement le plus petit sans mémoriser les rectangles les plus petits pour améliorer sa recherche. On peut facilement en déduire que plus la liste sera longue et plus le tri perdra de son intêret. De par sa démarche, en termes de comparaison, celui-ci est très coûteux car si on trie une liste de taille n alors on fera n(n+1)/2 comparaisons. Voici son code :</p>
<pre><code>def select_sort(self):

    tab = self.List_height
    n = len(tab)
    for current in range(0, n):
        smaller = current
        for j in range(current+1, n):
            if tab[j] &lt; tab[smaller]:
                smaller = j
        if min is not current:
            temp = tab[smaller]
            tab[smaller] = tab[current]
            tab[current] = temp
</code></pre>

<h3>1.3) Le tri rapide</h3>
<p>Le tri rapide est généralement le tri le plus utilisé. C'est un tri récursif qui repose sur le principe de &quot;diviser pour régner&quot;. Le but est de choisir dans notre liste un élément de taille moyenne et de s'en servir comme pivot. Le tri rapide va alors déplacer tous les éléments plus petits que le pivot à gauche et tous les éléments plus grands à droite. Puis il va répéter cette opération sur la zone gauche et droite et ainsi de suite récursivement jusqu'à se retrouver au cas de base qui est celui d'une liste de 2 éléments ( l'un plus grand l'autre plus petit ).On peut remarquer ici qu'à la fin de chaque répartition, le pivot est précisément à la place où il doit être puisque tous ceux plus grands sont à droite et tous ceux plus petits à gauche. Voici son code :</p>
<pre><code> def quick_sort(self, start, end):

    if start &lt; end:
        pivot = self.quick_sort_partition(start, end)
        self.quick_sort(start, pivot)
        self.quick_sort(pivot + 1, end)
</code></pre>

<hr />
<pre><code>def quick_sort_partition(self, start, end):

    ind_pivot = self.research_pivot(start, end)
    self.List_height[ind_pivot], self.List_height[start] = self.List_height[start], self.List_height[ind_pivot]
    pivot = start

    for i in range(start + 1, end):
        if self.List_height[i] &lt;= self.List_height[pivot]:
            stock = self.List_height[pivot]
            self.List_height[pivot] = self.List_height[i]
            for j in range(0, i-pivot-1):
                self.List_height[i - j] = self.List_height[i - j - 1]
            pivot += 1
            self.List_height[pivot] = stock

    return pivot
</code></pre>

<p>Dans le pire des cas, c'est-à-dire si, à chaque niveau de la récursivité le découpage conduit à trier un sous-tableau de 1 élement et un sous-tableau contenant tout le reste, le tri rapide n'est pas intéressant. L'intérêt de ce tri repose entièrement sur le choix du pivot. Si le pivot est aléatoire, alors il est possible de tomber sur un pivot faible qui entraînera donc le pire des cas. C'est pourquoi dans notre version du tri rapide, nous avons créé une focntion supplémentaire permettant de rechercher l'élément moyen de la liste qui sera notre pivot. Ainsi nous sommes dans le meilleur des cas et l'animation est plus claire et fluide. Voici le code permettant la recherche de ce pivot moyen :</p>
<pre><code>def research_pivot(self, start, end):

    maxi = self.List_height[start]
    mini = self.List_height[start]

    for m in range(start, end):
        if self.List_height[m] &gt; maxi:
            maxi = self.List_height[m]
        if self.List_height[m] &lt; mini:
            mini = self.List_height[m]

    mid = (maxi + mini) / 2

    x = abs(mid - self.List_height[start])
    pivot = start

    for m in range(start, end):
        if abs(mid - self.List_height[m]) &lt; x:
            pivot = m
            x = abs(mid - self.List_height[m])

    return pivot
</code></pre>

<h3>1.4) Le tri fusion</h3>
<p>Le tri fusion est aussi un tri récursif qui se base sur le même principe &quot;diviser pour régner&quot; que le tri rapide. Dans un premier temps, il va séparer la liste en deux, puis il va trier chaque partie séparément et enfin il va fusionner les deux parties triées en une seule. Son cas de base est celui de 2 listes de 1 élément qu'il va fusionner. Voici notre code :</p>
<pre><code>def merge_sort(self, start, end):

    if start &lt; end:
        mid = (start + end - 1) // 2

        self.merge_sort(start, mid)
        self.merge_sort(mid + 1, end)
        self.merge(start, mid, end)
</code></pre>

<hr />
<pre><code>def merge(self, start, mid, end):

    l_init = self.List_height[:]
    memory = []
    memory[:] = self.List_height

    size_left = mid - start + 1
    size_right = end - mid

    left = [0]*size_left
    pos_left = [0]*size_left

    rigth = [0]*size_right
    pos_rigth = [0]*size_right

    for i in range(0, size_left):
        left[i] = memory[start + i]
        pos_left[i] = start + i
    for i in range(0, size_right):
        rigth[i] = memory[mid+1+i]
        pos_rigth[i] = mid+1+i

    index_left,  index_right = 0, 0
    index = start

    while index_left &lt; size_left and index_right &lt; size_right:

        if left[index_left] &lt;= rigth[index_right]:
            l_init[index] = left[index_left]
            index_left += 1
        else:
            l_init[index] = rigth[index_right]
            index_right += 1
        index += 1

    while index_left &lt; size_left:
        l_init[index] = left[index_left]
        index_left += 1
        index += 1

    while index_right &lt; size_right:
        l_init[index] = rigth[index_right]
        index_right += 1
        index += 1

    self.List_height[:] = l_init
</code></pre>

<h3>1.5) Le tri par base</h3>
<p>Le tri par base est un tri totalement différent de tous ceux vus précédemment. En effet, sa caractéristique est qu'il trie notre liste en ne faisant <strong>aucune comparaison</strong>. Cela peut premièrement paraître inconcevable mais il existe plusieurs tris de ce genre de nos jours. Il existe plusieurs façons d'implémenter ce tri mais pour que cela soit plus facile à comprendre, nous allons vous l'expliquer dans la base que nous utilisons tous le plus : la base 10.	</p>
<p>Prenons par exemple cette liste : [ 48 , 56 , 89 , 152 , 8 , 954 , 37 ].</p>
<p>Premièrement, on va trier selon la valeur de l'unité: [ 4<strong>8</strong> , 5<strong>6</strong> , 8<strong>9</strong> , 15<strong>2</strong> , <strong>8</strong> , 95<strong>4</strong> , 3<strong>7</strong> ].</p>
<p>Cela donne donc : [ 15<strong>2</strong> , 95<strong>4</strong> , 5<strong>6</strong> , 3<strong>7</strong> , 4<strong>8</strong> , <strong>8</strong> , 8<strong>9</strong> ]</p>
<p>On repart de cette nouvelle liste et on fait de même pour les dizaines : Dans le cas où le nombre n'a pas de dizaine, on le traite comme si c'etait un &quot;0&quot;. Ainsi 8 et 08 représentent bien la même valeur numérique.</p>
<p>[ 1<strong>5</strong>2 , 9<strong>5</strong>4 , <strong>5</strong>6 , <strong>3</strong>7 , <strong>4</strong>8 , <strong>0</strong>8 , <strong>8</strong>9 ]</p>
<p>Devient ...</p>
<p>[ <strong>0</strong>8 , <strong>3</strong>7 , <strong>4</strong>8 , 1<strong>5<strong>2 , 9</strong>5</strong>4 , <strong>5</strong>6 , <strong>8</strong>9 ]</p>
<p>Puis aux centaines : </p>
<p>[ <strong>0</strong>08 , <strong>0</strong>37 , <strong>0</strong>48 , <strong>1</strong>52 , <strong>9</strong>54 , <strong>0</strong>56 , <strong>0</strong>89 ]</p>
<p>Devient finalement ...</p>
<p>[ <strong>0</strong>08 , <strong>0</strong>37 , <strong>0</strong>48 , <strong>0</strong>56 , <strong>0</strong>89, <strong>1</strong>52 , <strong>9</strong>54 ]</p>
<p>On a bien trié notre liste sans aucune comparaison !
Voici notre code :</p>
<pre><code>def radix_sort(self):

    modulo = 10
    div = 1
    new_list = []
    final = sorted(self.List_height)

    while self.List_height != final:

        ind_memory = [[],  [],  [],  [],  [],  [],  [],  [],  [],  []]

        for ind_value in range(len(self.List_height)):

            least_digit = self.List_height[ind_value] % modulo
            least_digit = int(least_digit / div)
            ind_memory[least_digit].append(ind_value)

        new_list[:] = []

        for i in range(len(ind_memory)):
            for j in range(len(ind_memory[i])):
                new_list.append(self.List_height[ind_memory[i][j]])

        self.List_height[:] = new_list
</code></pre>

<h2>Partie 2 : Présentation de notre évolution sur le projet</h2>
<p>Après cette présentation générale des tris, rentrons maintenant dans le coeur du sujet. Pour réaliser ce projet, nous avons utilisé Tkinter ( pour l'animation visuelle ) et Pygame ( pour l'animation sonore ). Notre objectif étant d'améliorer la compréhension des tris à l'aide d'une animation visuelle claire et compréhensible, nous avons décidé de créer un ensemble de rectangles de hauteurs toutes différentes et de les mettre dans le désordre. Notre projet permettra de trier cette ensemble chaotique de rectangles en les triant dans l'ordre croissant tout en faisant ressortir le fonctionnement de chaque tri. Le problème majeur auquel nous avons été confrontés est que, au final, trier une liste de hauteurs revient aussi à gérer une liste de rectangles. Pour réussir à trier les 2 listes sans que cela ne devienne trop complexe, nous avons misé notre code sur un seul concept : la parallélisme. </p>
<p>En effet, lors de la création d'un rectangle, celui-ci possède un identifiant que nous avons rangé dans une liste ( la liste de rectangles ), ce qui nous permet maintenant de parler d'un rectangle grâce à son indice dans la liste.
On met ainsi en parallèle 3 ensembles :</p>
<ul>
<li>La liste d'identifiants de rectangles</li>
<li>La liste de leurs hauteurs</li>
<li>Leur place sur le canevas</li>
</ul>
<p>Cette approche nous a permis de factoriser nos actions. En effet, quelle que soit l'action que l'on désire faire sur 2 rectangles, ils seront chacun au même endroit dans chaque liste. C'est grâce à ce système que nous avons pu mettre en place le modèle MVC pour traiter séparément la liste des hauteurs ( tout ce qui est manipulation des données et calcul ) puis le traitement de la liste d'animation qui comporte toutes les manipulations réalisées dans cette phase et enfin le résultat visuel. </p>
<h3>2.1) Implémentation des tris graphiquement</h3>
<p>Après de nombreuses phases expérimentales sur comment faire ressortir le plus clairement possible les caractéristiques de chaque tri, nous avons finalement mis au point un système plutôt efficace.
Notre code est découpé en 3 classes distinctes.</p>
<p>Nous avons premièrement la classe <strong>Sort</strong> qui trie une liste donnée de chiffres ( qui sont en réalité des hauteurs de rectangles ) et qui renvoie une nouvelle liste contenant des tuples composés généralement de 2 indices (comparé,courant) qui permettent de savoir de quel rectangle de notre liste nous parlons et d'un string indiquant l'opération à effectuer (échanges, comparaisons, pivot, minimum, ...). Cette liste permettra à notre classe principale d'animer le tri.</p>
<p>Parlons maintenant de la classe <strong>Help</strong>. Cette classe a été créée pour donner plus de précisions à l'utilisateur sur ce qu'il voit. C'est une fenêtre où l'on peut sélectionner le tri pour lequel on veut avoir des précisions et qui, pour chaque couleur, indique l'objet qu'il réprésente.</p>
<p>Parlons maintenant de notre classe principale : la classe <strong>Animation</strong>. Elle représente 70% de notre code car elle contient l'ensemble des boutons et autres widgets de Tkinter, l'ensemble des fonctions d'animation définies pour chacun des 5 tris, l'ensemble des fonctions utiles aux options que nous proposons à l'utilisateur.</p>
<p>La classe <strong>Animation</strong> est en fait une fenêtre qui contient le canevas où toutes les animations se produiront. La démarche d'animation de chaque tri suit un schéma particulier que nous avons reproduit afin de gagner en lisibilité et structure. L'animation d'un tri se fait donc toujours de la manière suivante :</p>
<ul>
<li>En cliquant sur le bouton du tri, on crée un élément Sort prenant en paramètre la liste des hauteurs des rectangles affichés sur le canevas. Celle-ci nous renvoie alors notre Liste d'animation.</li>
<li>L'animation de cette liste est ensuite gérée par un &quot;conducter&quot; ( chef d'orchestre ) qui, selon l'action requise ( positionnée généralement en 3ème composante ), va rediriger ce tuple à la fonction capable de réaliser cette action.</li>
<li>Une fois l'action traitée comme requise, on passe à un nouveau tuple dans la liste d'animation.</li>
<li>Ce routage s'éxécute tant que tous les tuples n'ont pas été traités.</li>
<li>( Falcultatif ) Une animation de vérification est parfois nécéssaire pour vérifier le bon déroulement de l'animation notamment pour le tri fusion, insertion et par base.</li>
</ul>
<p>Maintenant que nous avons vu le cas général et théorique, essayons de comprendre précisément le fonctionnement de l'un de ces tris: Le tri Insertion.</p>
<h6>La pression du bouton insertion entraîne l'animation du tri</h6>
<hr />
<pre><code>def button_animation_insertion_sort(self):

    self.settings_speed()  # on met à jour la vitesse
    self.reset_var()  # on réinitialise les variables

    if not self.ending:  # si le tri est fini et qu'on veut refaire le tri sur une liste dèjà triée ...
        self.creation()  # ... on ne peut pas ! A la place on créer un nouveau Diagramme
    else:
        self.safety_on()  # on désactive tout les boutons
        self.S.insert_sort()  # on trie...
        self.conductor_insertion_sort()  # ...puis on anime
</code></pre>

<h6>La première étape est donc calculatoire. On va créer notre liste d'animation :</h6>
<hr />
<pre><code>def insert_sort(self):

    for i in range(1, len(self.List_height)):  # pour chaque élément de la liste[1:]

        current = self.List_height[i]  # on désigne le rectangle à trier
        j = i  # j est une variable décroissante qui va nous permettre de comparer avec les autres rectangles

        while j &gt; 0 and self.List_height[j - 1] &gt; current:  # on cherche à placer le rectangle courant là où il faut
            # les conditions de sortie de boucle sont si current est le plus petit ( ie j=0 ) ou si un autre élément est plus petit que current
            self.List_animation.append((j - 1, j, &quot;c&quot;))  # si on est dans aucun de ces cas alors l'action est une comparaison
            self.List_height[j - 1], self.List_height[j] = self.List_height[j], self.List_height[j - 1]  # on inverse les éléments dans la liste car current &lt; comparé
            j = j-1  # on décremente j

        self.List_animation.append((j, i, &quot;e&quot;))  # on fait une échange
</code></pre>

<h6>L'animation peut commencer. Le chef d'orchestre est là pour router les tuples vers l'action demandée et vérifier que l'utilisateur n'a pas appuyé sur Pause</h6>
<hr />
<pre><code>def conductor_insertion_sort(self):  # chef d'orchestre qui choisit le type d'animation

    if self.ind_current &gt;= len(self.S.List_animation):  # si on a fini de tout trier...
        self.canevas.itemconfig(&quot;ok&quot;, fill=&quot;white&quot;)  # s'il rester un rectangle colorié on le rend blanc
        self.canevas.dtag(&quot;ok&quot;, &quot;ok&quot;)  # on le dtag
        self.verif()  # Fonction de vérification
    else:
        self.update_comp()  # on met à jour sur le canevas le nombre de comparaisons
        self.settings_speed()  # on met à jour la vitesse

        if not self.stop:  # si le pgrm n'est pas en pause

            if str(self.S.List_animation[self.ind_current][2]) == &quot;e&quot;:  # &quot;e&quot; = echanges
                nbr_move = self.S.ind_swap  # le nbr de rectangles à décaler sur le canvas
                self.S.reset_swap()  # indice_echange = 0 pour recommencer à partir d'un nouveau rectangle
                rect_courant = self.S.List_animation[self.ind_current][1]  # le rectangle que l'on veut trié
                self.animation_swap_insertion(nbr_move, rect_courant)

            elif str(self.S.List_animation[self.ind_current][2]) == &quot;c&quot;:  # &quot;c&quot; = comparaisons
                self.counter_comparison += 1  # et d'une comparaisons de plus
                self.S.ind_swap += 1  # un décalage supplémentaire sera nécéssaire pour l'animation de l'échange
                self.animation_comparisons_insertion()
        else:
            self.Window.after(self.turbo, self.conductor_insertion_sort)  # on boucle sur lui-même si on est en pause
</code></pre>

<h6>L'action est une comparaison. C'est la fonction ci-dessous qui la traite</h6>
<hr />
<pre><code>def animation_comparisons_insertion(self):  # anime une comparaison

    self.canevas.itemconfig(&quot;comp&quot;, fill=&quot;white&quot;)  # on efface les traces de la derniere action
    self.canevas.itemconfig(&quot;ok&quot;, fill=&quot;white&quot;)  # on efface les traces de la derniere action
    self.canevas.dtag(&quot;comp&quot;, &quot;comp&quot;)  # on efface les traces de la derniere action
    self.canevas.dtag(&quot;ok&quot;, &quot;ok&quot;)  # on efface les traces de la derniere action

    rect_compare = self.List_rectangles[self.S.List_animation[self.ind_current][0]]  # le rectangle que l'on compare
    rect_courant = self.List_rectangles[self.S.List_animation[self.ind_current][1]]  # le rectangle que l'on veut trier

    if self.S.ind_swap == 1:  # si c'est la première echange faire...
        self.canevas.itemconfig(rect_courant, tags=&quot;courant&quot;)

    self.canevas.itemconfig(rect_compare, tags=&quot;comp&quot;)  # on tag le rectangle que l'on compare pour le reconnaîre
    self.canevas.itemconfig(&quot;courant&quot;, fill=self.color_current)  # on colorie en vert le rect que l'on veut trier
    self.canevas.itemconfig(&quot;comp&quot;, fill=self.color_comp)  # on colorie en rouge le rect avec lequel on le compare

    self.ind_current += 1  # on passe au prochain tuple dans la liste d'animation
    self.Window.after(self.turbo, self.conductor_insertion_sort)  # on reprend l'animation de la liste complete
</code></pre>

<h6>L'action est un échange. C'est la fonction ci-dessous qui la traite</h6>
<hr />
<pre><code>def animation_swap_insertion(self, place, current):  # anime une echange

    self.canevas.itemconfig(&quot;ok&quot;, fill=&quot;white&quot;)  # on efface les traces de la derniere action
    self.canevas.itemconfig(&quot;comp&quot;, fill=&quot;white&quot;)  # idem
    self.canevas.dtag(&quot;ok&quot;, &quot;ok&quot;)  # idem

    thickness = self.weight / self.nbr  # on cherche l'epaisseur du rectangle qui va permettre le depl sur le canvas
    stock = self.List_rectangles[current]  # on stocke le rectangle que l'on veut trier

    for i in range(1, place + 1):  # on decale tous jusqu'à l'endroit où il doit être inséré
        self.List_rectangles[current - i + 1] = self.List_rectangles[current - i]  # on decale vers la droite les elements
        self.canevas.move(self.List_rectangles[current - i], thickness, 0)   # on decale vers la droite d'une largeur de rectangle

    self.List_rectangles[self.S.List_animation[self.ind_current][0]] = stock  # on reinsere le rectangle courant à sa place
    self.canevas.move(stock, -place * thickness, 0)  # on deplace le rectangle courant à sa place sur le canvas
    self.canevas.itemconfig(self.List_rectangles[self.S.List_animation[self.ind_current][0]], tags=&quot;ok&quot;)  # le rectangle est trié on le tag &quot;ok&quot;
    self.canevas.itemconfig(&quot;ok&quot;, fill=self.color_moved)  # le rectangle est colorié en jaune où il est inséré

    self.ind_current += 1  # on passe au prochaine tuple de la liste d'animation
    self.Window.after(self.turbo, self.conductor_insertion_sort)  # on reprend l'animation de la liste complete
</code></pre>

<h6>Pourquoi ce choix d'implémentation visuelle ?</h6>
<p>Contrairement à la vidéo youtube sur laquelle nous nous sommes basés pour réaliser ce projet (<a href="https://www.youtube.com/watch?v=kPRA0W1kECg">lien vers cette vidéo</a>), nous avons porté notre attention sur la partie visuelle et non sonore du tri car seule une oreille musicale pourrait comprendre les spécificités de chaque tri. Ainsi nous avons choisi de faire apparaître toutes les comparaisons et les échanges avec des codes couleurs respectifs dans le but de montrer à chaque étape le déroulement du tri et le nombre de comparaisons réalisées. </p>
<h3>2.2) Le problème du tri fusion et du tri par base</h3>
<p>.
Le tri fusion et le tri par base sont des tris dits externes. C'est-à-dire que les éléments ne peuvent pas être simplement échangés dans la liste initiale. Il faut une autre liste ou parfois de nombreuses autres listes pour ranger les éléments dedans et ensuite les recomposer avec l'initiale. Ce problème engendre notamment une augmentation de la complexité spatiale car plus la liste à trier est grande, plus les copies de cette liste vont prendre de place dans la mémoire. Ainsi, la mémoire vive peut rapidement être compromise et le trop plein sera donné au disque. Or, les appels sur le disque sont bien plus longs à la récupération des données que ceux en mémoire vive d'où les faiblesses de ces tris.</p>
<p>Dans le but de rappeler à l'utilisateur cette faiblesse, nous avons décidé de faire une superposition de la liste de base et de la copie de cette liste où les actions vont être traitées. Ce qui, sur le canevas, se matérialisera par une superposition de rectangles. L'animation est tout de même réalisée dans un but d'apprentissage et cette superposition n'est en rien un obstacle à la compréhension du fonctionnement de ces deux tris.</p>
<p>Concernant, plus précisément, le tri Radix, un problème survient avec la compatibilité de notre code. Une hypothèse nécessaire à l'utilisation du tri Radix est celle que la liste soit composée d'entiers. Cependant, pour obtenir cette belle pente à la fin de chaque tri, nous avons dû faire en sorte que les tailles soient proportionnelles. En d'autres termes, pour un grand nombre de diagrammes, les hauteurs sont flottantes et l'utilisation du tri Radix n'est pas compatible. Pour y remédier, on arrondit à l'unité près, ce qui nous permet de manipuler des entiers tout en influant négligemment la proportionalité de la courbe.</p>
<p>La façon dont nous avons codé la création du diagramme pose un autre problème concernant le Radix. Par exemple, pour 10 rectangles, l'unité de chaque hauteur des rectangles est la même et on se retrouve donc avec tous les rectangles de la même couleur lors du repérage de l'unité. Le rendu n'est pas très agréable et pour comprendre son fonctionnement, tester sur un exemple pair n'aide pas vraiment à la compréhension de l'utilisateur. L'animation n'en est cependant pas moins juste. Elle est simplement moins représentative des fluctuations d'un nombre aléatoire de données.</p>
<h2>Partie 3: Présentation de l'application et de ses fonctionnalités</h2>
<p>Dans cette partie, nous allons vous parler des différentes fonctionnalités que nous avons implémentées pour donner plus de contrôle à l'utilisateur et ainsi permettre à chacun de comprendre à sa façon. </p>
<h3>3.1) Le contrôle du temps</h3>
<p>Pour fournir à l'utilisateur le temps dont il a besoin pour comprendre le fonctionnement du tri, nous avons implémenté un slider qui permet d'accélérer ou de ralentir l'animation de sorte que l'on puisse prendre le temps de comprendre un passage ou de passer rapidement sur un passage bien maîtrisé.</p>
<p>L'utilisateur a aussi la possibilité de mettre en pause le programme grâce à la barre d'espace puis de le remettre en route par une nouvelle pression de cette touche. L'état de l'animation est alors représenté par le biais de 2 images &quot;ON&quot; et &quot;OFF&quot; qui font comprendre que le programme est soit en pause, soit actif.</p>
<p>Un autre problème que nous avons résolu est celui du nombre de rectangles. Si la vitesse initiale n'était pas influencée par le nombre de rectangles, on comprend bien que pour trier une liste de 300 rectangles, on peut revenir le lendemain. Pour y remédier, nous avons implémenté une fonction turbo qui accélère la vitesse de traitement de l'animation: plus il y a de rectangles, plus l'animation est accélérée. Voici son code :</p>
<pre><code>def settings_speed(self):
    if int(self.nbr) &lt; 150:  # self.nbr est notre nombre de rectangle 
        self.turbo = self.sliderspeed.get()
    else:
        self.turbo = self.sliderspeed.get()//((self.nbr % 100)+1)
</code></pre>

<h3>3.2) Les restrictions imposées à l'utilisateur et leurs souplesses</h3>
<p>La fenêtre d'aide ne peut pas être ouverte plus d'une fois en même temps. Un try / except nous permet de savoir quand une fenêtre existe déjà ou si elle a été détruite. Cliquer sur le bouton d'info alors qu'une fenêtre est déjà ouverte fermera la fenêtre initiale et en réouvrira une nouvelle.</p>
<p>Pour des besoins de clarté, en plus de la classe <strong>Help</strong> ( qui est disponible via le bouton &quot;Info&quot; ), nous avons amélioré la lisibilité lorsque le diagramme possède trop de rectangles ( ici, nous avons défini ce cap à 300 rectangles ). En effet, avec Tkinter, le bord des rectangles est automatiquement ajouté et nous l'avons laissé car le rendu est plus appréciable sur un petit nombre de rectangles. Mais pour dessiner ces bordures, des pixels y sont forcément alloués et l'on perd ainsi en capacité de nombre de rectangles car notre diagramme ressemble à un négatif.</p>
<p>Pour valider son choix de diagramme, l'utilisateur peut soit utiliser le bouton créé dans ce but, soit appuyer sur Entrée qui aura le même effet. Une méthode administrator() est appelée en cas d'événement qui traite la barre d'espace et la touche Entrée.</p>
<p>Nous avons défini le nombre maximum de rectangles possible à 500. Si l'utilisateur décide de dépasser cette limite, une méthode de <strong>Animation</strong> nommée too_much() force le nombre de rectangles à 499. Voici son code :</p>
<pre><code>def too_much(self):  # on regarde si il y trop de rectangles à supporter pour le canvas
    field_entry = int(self.field.get())  # on récupère le nbr de rectangles saisie
    if field_entry &gt;= 500:  # si il est plus grand que 500 qui est ici le maximum accepté...
        self.field.delete(0,END)  # on supprime la valeur du champ
        self.field.insert(INSERT, 499)  # on la remplace par une valeur par défaut
    self.nbr = int(self.field.get())  # le nbr de rectangle peut maintenant récupérer la valeur du champ
</code></pre>

<p>Pour guider l'utilisateur dans sa démarche de compréhension de notre application, nous avons ajouté des sécurités pour que, par exemple, il soit impossible de lancer un nouveau tri s'il y en a déjà un en train de s'animer. Pour cela, nous avons désactivé les boutons dès lors qu'un tri s'anime. Les boutons ne seront disponibles qu'à la toute fin de l'animation. Cependant, il n'est pas impossible d'interrompre l'animation d'un tri. Pour cela, il suffit de créer un nouveau diagramme grâce à son bouton. Dans ce cas, un nouveau diagramme apparaîtra et les boutons des tris seront de nouveau accessibles.</p>
<h3>3.3) Le tri sonore</h3>
<p>Le tri sonore est un aspect de notre programme que nous avons mis de côté intentionnellement pour se concentrer notamment sur une parfaite réalisation de l'animation visuelle de nos tris. Nous avons, en fin de compte, essayé de l'implémenter avec Pygame sur le tri Selection car c'est le tri le plus monotone dans ses actions donc le plus intuitif pour tester de nouvelles idées.</p>
<p>De nombreuses difficultés sont tout de suite apparues. La conception que nous avions de l'animation sonore était un bruit pour chaque action différente (comparaison, échange et minimum). Le rendu est disponible sur l'application et il faut reconnaître qu'il aurait été préférable de ne jamais l'avoir écouté. Cependant cette basique implémentation a révélé de nombreuses limites notamment celle du temps. En effet, Pygame ne possède aucun module capable de gérer la durée d'un son proportionnellement: impossible de pouvoir compresser ou décompresser un son selon la vitesse que l'utilisateur a imposée. Le rendu n'a alors plus aucun sens. L'animation sonore et visuelle sont en décalage complet et le projet y perd plus qu'il n'en gagne. Nous avons donc décidé de ne pas l'implémenter aux autres pour les préserver.</p>
<p>Pour épargner les oreilles de l'utilisateur qui osera écouter l'implémentation sonore, nous avons créer un bouton audio qui permet de couper le son ou de le remettre alternativement à chaque nouvelle pression. Pour information, ce bouton n'est utilisable que dans la mesure où le tri que l'on regarde est le sélection. Dans le cas échéant, le bouton est désactivé. </p>
<p>En fait, pour réussir cette animation sonore, il aurait fallu la voir comme une animation musicale. Ces 2 concepts sont totalement différents, la musique implique de l'harmonie; ce dont notre implémentation est totalement dépourvue. Il aurait fallu prendre beaucoup de paramètres en question comme la taille des rectangles, l'indice où on les place, une fréquence variable selon l'écart entre deux rectangles de tailles différentes, etc... Seule une oreille musicale aurait pu nous aider à déterminer ces paramètres et nous n'en n'avions malheureusement pas sous la main dans les temps impartis.</p>
<h2>Conclusion</h2>
<p>En conclusion, ce projet nous a beaucoup appris.</p>
<h6>Sur le plan de nos connaissances en programmation :</h6>
<p>Ce projet nous a apporté de toutes nouvelles connaissances dans la programmation graphique avec le module Tkinter. Partant de zéro, nous avons appris à utiliser les différentes méthodes pour déplacer des objets, pour les manipuler grâce à leurs identifiants ou encore pour réaliser une animation sans manuellement forcer le rafraîchissement de la fenêtre via la méthode <strong>.after()</strong>. Nos débuts étaient très machinals et intuitifs mais grâce aux nombreux supports d'aide sur Internet et à l'accompagnement de Mr Ortiz, nous avons su améliorer notre code en le regardant sous une autre perspective.</p>
<p>Nous avons aussi grâce à nos cours d'informatique résolu le problème des tris externes notamment par le biais du clonage d'une liste ou de sa deepcopy(). C'est ce point essentiel qui nous a permis de résoudre ce problème.</p>
<h6>Sur le plan de nos connaissances sur les tris :</h6>
<p>Bien que nous connaissions l'existence de la plupart de ces tris, il est vrai que nous les avions rarement manipulés aussi structurellement. Nous connaissions le principe de chacun et le classement des performances mais le fait d'avoir décomposé les tris de façon séquentielle, nous a permis aujourd'hui de les manipuler et de les expliquer aisément. Cela nous a notamment été utile durant nos cours de complexité des algorithmes où nous les avons manipulés. </p>
<p>Les tris sans comparaisons ont été en revanche une découverte. Nous ne connaissions pas l'existence de tels tris et il est vrai, qu'après de nombreuses recherches, ils sont beaucoup plus intuitifs pour l'Homme ( dans sa manipulation constante des chiffres ) que ceux adaptés pour ordinateur.
Bien que ces algorithmes peuvent être utilisés sous hypothèse sur la liste à trier, ils n'en restent pas moins très intéressants à connaître et à apprendre.</p>
<h6>Sur le plan de nos connaissances sur la POO :</h6>
<p>Nous avions déjà vu la POO en java pendant notre cursus mais nous avons eu du mal à le réapliquer et nous avons commencé notre projet en un seul bloc avec beaucoup de variables globales. Compte tenu des attentes demandées, nous avons réimaginé notre conception de notre code, surtout pour respecter le modèle MVC. Malgré nos efforts, nous reconnaissons que les séparations entre les 3 entités peuvent être floues. Nous avons eu beaucoup de difficultés à introduire l'héritage d'autres classes et à séparer les tris car ils utilisent autant de variables en commun que particulières à eux-mêmes.</p>
<p>De toutes les difficultés auxquelles nous avons dû faire face, la POO a été la plus compliquée à surmonter. Au fur et à mesure de la conception du programme, nous pouvions voir de nouvelles structures MVC capables de mieux découper notre code mais, contraints par le temps, nous ne pouvions pas nous permettre de reprendre notre code tant que nous ne l'avions pas complètement réalisé. Les tris externes nous ont demandé beaucoup de travail de recherche et de réflexion qui ne nous ont pas laissé la possibilité d'implémenter ces nouvelles stuctures.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
